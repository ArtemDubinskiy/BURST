/*
 * Проект:   BURST(Brutal Utilization & Resilience Stress Testing)
 * Автор:    Дубинский Артем {dub}
 */

namespace BURST.Types.Base
{
    /// <summary>
    /// Интерфейс одного стресс-теста.
    /// <para>
    /// Контракт любой нагрузки состоит из двух стадий:
    /// <list type="number">
    ///   <item>
    ///     <description><see cref="RunTest"/> - выполнить основной участок вычислений/операций ввода-вывода/работы с памятью. Допускается кешировать промежуточные результаты во внутренних полях экземпляра.</description>
    ///   </item>
    ///   <item>
    ///     <description><see cref="Validate"/> - проверить корректность результатов предыдущего прогона (инварианты, контрольные суммы, допуски по точности и пр.). При некорректности необходимо <b>бросить исключение</b>, чтобы инфраструктура зафиксировала ошибку и остановила поток ядра.</description>
    ///   </item>
    /// </list>
    /// </para>
    /// <remarks>
    /// Назначение такого деления - чётко отделить вычисления от валидации, чтобы при необходимости можно было менять стратегию проверки без изменения тестовой нагрузки.
    /// </remarks>
    /// </summary>
    public interface IStressTest
    {
        /// <summary>
        /// Выполнить основную работу теста.
        /// Можно сохранять промежуточные результаты во внутренние поля.
        /// Не должно бросать исключения при штатной работе, иначе поток ядра будет остановлен.
        /// </summary>
        void RunTest();

        /// <summary>
        /// Проверить корректность результатов предыдущего прогона.
        /// Должно бросать исключение при любой аномалии - это будет перехвачено верхним уровнем,
        /// записано в <c>ErrorState</c> и выведено в монитор.
        /// </summary>
        void Validate();

        /// <summary>
        /// Режимы планирования выполнения набора тестов.
        /// </summary>
        public enum ExecutionMode
        {
            /// <summary>
            /// Последовательно по тестам: каждый тест выполняет все свои циклы, затем следующий.
            /// </summary>
            SequentialByTest = 1,

            /// <summary>
            /// По одному циклу от каждого теста по кругу, пока у всех не закончатся циклы.
            /// </summary>
            RoundRobinByCycle = 2,

            /// <summary>
            /// Случайный выбор следующего теста из тех, у кого остались циклы; выполняется ровно один цикл.
            /// </summary>
            Random = 3
        }
    }
}
